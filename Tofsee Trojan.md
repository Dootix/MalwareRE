**Overview**

As per Malpedia, Tofsee (aka. Gheg) is a modular Trojan-like malware, capable of crypto mining, botnet activities, infostealing, DDoS attacks and many more. It's broad functionality is possible thanks to the ease of modularity.

Based on the Anomali TI, Tofsee's usage can be connected with four APTs:

- Emissary Panda
- Stone Panda
- Mummy Spider
- APT27

![image](https://github.com/user-attachments/assets/05180f1b-a127-4a24-b57d-b8acd1c3aeac)

Based on Spamhaus.com report for 2023, it's ranked 14th based on malware families associated with botnet C2s.

![image](https://github.com/user-attachments/assets/95459142-1e73-473a-b04b-1598a068c208)

**Static Analysis - 1st stage**

- SHA256: 8eb33da353d3756d8cd4cb9308fd5ef72a9b35441bec41fd17c3f3ee508ea9ab
- Sample: https://bazaar.abuse.ch/sample/8eb33da353d3756d8cd4cb9308fd5ef72a9b35441bec41fd17c3f3ee508ea9ab/

DIE check tells us that the file is a Windows PE and has been compiled in Visual Studio. We can see both compiler and linker pointing to VS.

![image](https://github.com/user-attachments/assets/739842c0-9dfc-41bc-ba07-ce00ccd9aebd)


We will now switch to PE-Bear/pestudio for further PE analysis. Signature in hex checks out. File is a PE file and has a valid e_lfanew field (pointer to the start of NT Headers).

![image](https://github.com/user-attachments/assets/73b9e9ad-9fa2-49a7-9753-cb8b1ad04c68)

By looking into the Optional Header, we can confirm that the sample is a 32-bit Windows GUI application.

![image](https://github.com/user-attachments/assets/0b87f5d6-6bf0-41f2-b10c-bc6f7160c50c)

Looking at the PE sections of the file, nothing abnormal is seen here. Judging by the initial checks, sample does not appear to be fully packed/compressed/encrypted due to following reasons:

- Raw sizes are very similar to virtual sizes. If the malware was in fact packed or compressed, its virtual size would be orders of magnitude higher than raw size on disk due to unpacking process at runtime.
- Strings appear to be plaintext, however some might be obfuscated. We will look at the strings in a moment.
- Entropy value is higher than usual for a PE. One can argue that it is in the higher end of a typical PE file is that may be due to the executable being a GUI application. This might add randomness to the data. It is also possible that some pointers/data is in fact encrypted/encoded and will be resolved during runtime.

![image](https://github.com/user-attachments/assets/3631b3ab-be61-4a32-84d6-f4e5cb881d75)

To finish off with the section headers checks, let's look into the .rsrc section for signs of any payload being hidden there. As we can see, resources section is mostly empty, containing only icons and cursors.

![image](https://github.com/user-attachments/assets/648cac93-f817-4dfc-ae64-7ec3c891b164)

Transitioning to the import table, we can notice that everything is visible in cleartext, which further confirms our theory that the malware is not packed or encrypted.

The sample imports kernel32.dll, GDI32.dll and ADVAPI32.dll. WinAPI/NTAPI imports will be analyzed later when we delve deeper into disassembly and debugging. However, the imports give us an overview on what the malware functionality is, so let's briefly list some of the more interesting functions below:

- WriteFile - writes data to a specified file
- ReadFile - reads content of the specified file
- CreateFile - creates a file
- SetFileAttributesW - changes attributes related to the file (i.e read-only, readwrite etc).
- VirtualProtect - memory protection manipulation, might be used to change specific memory region's permissions to execute code. PAGE_EXECUTE_READWRITE would be the most obvious one.
- Sleep
- SetComputerNameExA - Sets a new NetBIOS name for the local host. Might be used when a computer is added to the botnet for identification.
- Heap manipulations. Not necessary evil, but worth looking into as malware might drop decoded/deobfuscated payload there.
- GetModuleHandleExW - obtaining a handle to a module already loaded to memory. Ex(extended) version of this API call lets you specify base memory address of the module instead of its name. While legitimate when there are many modules with the same name loaded, the - functionality might be used to load malicious and memory-only code that is not backed up with an image on the disk.
- EncodePointer / DecodePointer - encoding/decoding a specific pointer with a provided key. Might be an anti-analysis measure to hide specific pointers provided to a function call. They will get decoded during runtime.

![image](https://github.com/user-attachments/assets/c6938ff5-2278-405c-bcb7-32b12d7fbdcd)

As stated earlier, strings are in plaintext. However, when we scroll to the end of the strings dump, we are presented with obfuscated strings. It's possible that this is another anti-analysis example of junk code, but these may also be pointers encoded via EncodePointer funcion. We will have to dig deeper to confirm.

![image](https://github.com/user-attachments/assets/186ccdd8-c0fa-4782-9801-5a398b920e31)

One more thing worth mentioning - basic dynamic analysis was not possible due to the malware removing itself right at the execution moment in the VM environment.

**Deep Analysis using IDA/x64dbg - 1st stage**
Let's fire up IDA and analyze the disassembled code and utilize IDA's built-in decompiler to see C pseudocode that will help us in the analysis. After that, we will use x64dbg to see what's going on during runtime.

Our initial entry point is wWinMain function with arguments passed to it, which is a standard calling convention entry point in GUI apps.

![image](https://github.com/user-attachments/assets/ca84a65f-b919-41d1-89aa-a8f84d594c07)

However, this might not be a true main function due to some code that is added when executable is created, it is worth double-checking it. One trick I've learned is that when we go to the "start" function label in IDA, we are presented with preprocessor/compiler boilerplate code.

![image](https://github.com/user-attachments/assets/521a2078-e106-401e-a249-204b94310e0b)

***__security_init_cookie*** is a function call that protects the program from buffer overflows. The second function, which is jumped to after returning from the cookie function is ***__tmainCRTStartup*** (name differs based on the compiler) in our case. This function contains exception handling routines, which are followed by call to main.

When we jump into __tmainCRTStartup and scroll down a little, we can see a specific registers with arguments being passed before a call to _wWinMain@16. This is in fact our main function and IDA has correctly pointed us to it.

![image](https://github.com/user-attachments/assets/5bdaa5f2-c357-4a42-9060-4522ac3fb1ee)

Let's head back to the main entry point. What immediately stands out is an absurd amount of variable declarations and mov operations to memory addresses with huge hex values. The code resembles antidebugging techniques as the values are not passed to any functions judging by lack of cross-references.

![image](https://github.com/user-attachments/assets/22a8ab86-839f-4c94-a462-630a9819c561)

![image](https://github.com/user-attachments/assets/4bcc16c9-e08a-4510-8e4d-2a253815a4ef)


If we look closely, we can see EDI register being XORed against itself, which consequently makes it 0. Then, EDI is copied into ESI.

![image](https://github.com/user-attachments/assets/1425881c-72d9-40a9-9e09-9cdfaef1cc6c)

Next block of disassembled code shows us various function calls, although the parameters passed don't make sense as there are all zeroed out.

![image](https://github.com/user-attachments/assets/699ee05f-edda-4234-a2f0-91ecaff4124c)

We can also see various for/if/while loops that are compared against zeroed registers, creating anti-debugging loops.

![image](https://github.com/user-attachments/assets/2645a917-9f28-460e-82a5-7052c6d1f713)

Not many interesting code snippets here. Let's visit sub_4014FC function as it is the only call to other subroutine before the main's return.

![image](https://github.com/user-attachments/assets/7b7f5aa1-436c-466f-b270-f2ff2040c16f)


Now, below code looks much more promising. We can see many suspicious actions being taken by the malware, such as passing the encoded/obfuscated strings as arguments, various interesting calls being invoked with valid parameters etc. This function contains much of the program's logic by the looks of it.

![image](https://github.com/user-attachments/assets/3ac1c529-ee2c-491b-b3cf-20a54a91eda8)

ECX register is incremented significantly and pushed onto the stack for LocalAlloc. This register is used as an uBytes argument (size in bytes to allocate). EBX is also pushed onto the stack.

![image](https://github.com/user-attachments/assets/1e47288e-9bbe-410e-9901-68c78bbdf68b)

Function returns a handle to EAX register, that is then passed to variable dword_472E3C.

Right after that, parameters to VirtualProtect are being passed as follows:

- ecx: pointer to variable containing old memory protection value in current block.
- 40h: new memory protection constant, in this case 0x40 is passed, which indicates highly dangerous PAGE_EXECUTE_READWRITE ) permissions.
- dwSize: size of the memory region to change permissions to. Matches dwSize from LocalAlloc, so the whole memory region gets execute/read/write permissions.
- eax: pointer to the address of the starting page in the memory region.

![image](https://github.com/user-attachments/assets/7401fcd4-f933-4e52-9b81-26154681eb3a)

To summarize current findings:

- wWinMain function contains a lot of anti-debugging junk code.
- We then entered sub_4014FC function. Here, LocalAlloc has been called to allocate memory region alongside VirtualProtect, changing its permissions to PAGE_EXECUTE_READWRITE.
- We now know that dword_472E3C is a variable containing the handle returned from LocalAlloc. We can rename it in our pseudocode to localalloc_rtrn_hndle for easier identification during the debugging process.

![image](https://github.com/user-attachments/assets/78f3a65b-83a0-467a-8eec-5f530e77e38e)

One function call also stands out, as it appears to be a data manipulation routine, having many values shuffled around in memory and registers, shifting bytes and XORing.

![image](https://github.com/user-attachments/assets/24e7b3c0-8186-4fc0-bf35-6f649fa288b2)


At the end of the function, we encounter the msimg32.dll being loaded into memory and right after that, call to EAX is made, which contains a handle to the code allocated in heap. Recall that the malware has allocated some memory with read/write/execute permissions. This might be the clue for execution of the suspected second stage of the malware.

![image](https://github.com/user-attachments/assets/db1a9fb0-c7cc-4f3d-8105-00042872436c)

**64dbg**
We jump straight to the LocalAlloc. Function is called, handle to freshly allocated memory (006D9FD8) is returned into EAX, then the handle is copied from EAX to the variable.

![image](https://github.com/user-attachments/assets/f9551d02-634f-46db-bfdd-ce3798667a4c)

When we follow the 006D9FD8 address in memory dump, we end up in the allocated space.

![image](https://github.com/user-attachments/assets/34c119ed-fabd-490e-a1c0-ce11445c6e1e)

Next, VirtualProtect is called, so the above region has RWX (read/write/execute) permissions now.

![image](https://github.com/user-attachments/assets/c68230ad-edd6-4862-9f16-6fb989902372)

Later on, we encounter the same data manipulation subroutine that is looping a lot of times. By the looks of it, it is manipulating/XORing data around the EBP base pointer. We see many pointers around EBP being passed to registers.

![image](https://github.com/user-attachments/assets/922d2cac-b8ba-4958-9c5a-9b5c3fbcb228)


After we break out of the loop and check the memory region allocated earlier, it is now filled with data. I exported the region into a file, however it does not return anything of value for our analysis. It is possible that the region is encrypted and is decrypted later.

![image](https://github.com/user-attachments/assets/065f6b17-a708-4db6-8abd-da35c49491e0)

As predicted during disassembly, msimg32.dll is loaded.

![image](https://github.com/user-attachments/assets/7df456dc-1829-4eed-8815-dd59b49963b8)

Call to EAX is then made, which at the moment contains a pointer to the allocated data in heap. However, we receive an error -> EXCEPTION_ACCESS_VIOLATION.

![image](https://github.com/user-attachments/assets/bc37a577-b0c2-43c4-b00b-b1f5d5ccf764)

Inspecting the memory map, not a single heap region have execute permissions now (but was changed before via VirtualProtect). It might be due to yet another layer of anti-debugging or a glitch due to manual manipulation of some loops to break out of them.

I couldn't get the sample to properly deploy the second stage via the debugger, so I decided to use UNPAC.me. It is a great resource for malware analysis as it detects packers/encryption and decrypts them, providing us with a clean sample. It was, in fact, packed in some way with a custom packer.

![image](https://github.com/user-attachments/assets/7d8431a1-529e-4499-bc4f-59f55cd4eb47)

Thanks to unpac.me, we now have a second stage to work with.

**Static analysis - 2nd stage**
File is a standard PE file. We can see much more interesting strings and imports, directly related to process injection, memory manipulation, shell execution, persistence and internet connection.

![image](https://github.com/user-attachments/assets/74234cbf-3980-48db-b203-eb0e77d33287)

**Deep analysis with IDA/x64dbg - 2nd stage**
Let's jump straight into IDA to assess the code. Right at the start, we can see that the malware creates a thread and calls WSAStartup, which is used for Windows sockets initialization for internet connection.

![image](https://github.com/user-attachments/assets/aa6ad989-7741-450e-b047-9be332f47e95)

Right after that, a function is called that is responsible for reading from a specific file. Might be a potential config file downloaded from the C2. The code is quite large, so we have to assess the most important parts of the disassembly - such as specific function calls and values provided to functions. As with the 1st stage, we are going to work in conjunction with the debugger.

Right after the main function, the malware is opening SYSTEM\CurrentControlSet\Services registry location.

![image](https://github.com/user-attachments/assets/2f1fee2e-6014-489c-8b54-b50529f40911)

It then jumps into a loop and, using RegEnumKeyA, is enumerating all of the registry keys present there.

![image](https://github.com/user-attachments/assets/69ba6df0-cda5-4a19-b0e4-d1cdde2f720f)

After breaking out of the loop, the sample is querying for ***AppData\Local\Temp*** of the current user and then is dynamically concatenating strings to create a path -> ***C:\Windows\SysWOW64\ponknbmf***

![image](https://github.com/user-attachments/assets/9b4edcf3-1edc-40c1-9088-f25b24565ba6)

File is dropped into local user's Temp folder and tampers with its attributes -> crjqvtyq.exe.

![image](https://github.com/user-attachments/assets/cb52f972-4964-434e-8331-8e888ca930be)

When we dig deeper into internals of the executable, we are presented with another great indicator:

***cmd /C mkdir %s\r\ncmd /C move /Y "%s" %s\r\nsc create %s binPath= "%s%s /d"%s"" type= own start= auto DisplayName= "wifi support"\r\nsc description %s "wifi internet conection"\r\nsc start %s\r\n***

Above command line makes a new directory (possibly C:\Windows\SysWOW64\ponknbmf) and copies additional malicious files there (presumably crjqvtyq.exe). Then, it creates a service named "wifi support" with description "wifi internet connection" and starts the service. Furthermore, svchost.exe from the SysWOW64 folder is used and firewall rule is added.

***netsh advfirewall firewall add rule name="Host-process for services of Windows" dir=in action=allow program="%s" enable=yes>nul\r\n***

![image](https://github.com/user-attachments/assets/467e006a-f421-44ec-9a37-c7c7ab9c68ff)

![image](https://github.com/user-attachments/assets/68f8568e-fc68-49b9-b27b-1722de2e54bf)

After that, registry key under ***\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System*** is queried for value of ***ConsentPromptBehaviorAdmin***. It's possible that it tries to modify the global value to avoid admin prompts when started as a service during logon.

***cmd /C mkdir C:\Windows\SysWOW64\ponknbmf\r\ncmd /C move /Y "C:\Users\dootix\AppData\Local\Temp\crjqvtyq.exe" C:\Windows\SysWOW64\ponknbmf\r\nsc create ponknbmf binPath= "C:\Windows\SysWOW64\ponknbmf\crjqvtyq.exe /d"C:\Users\dootix\Desktop\tofsee2"" type= own start= auto DisplayName= "wifi support"\r\nsc description ponknbmf "wifi internet conection"\r\nsc start ponknbmf\r\nnetsh advfirewall firewall add rule name="Host-process for services of Windows" dir=in act***

**Extracted Intelligence**
List of successfully extracted IOCs is presented below.

Atomic indicators:

141.8.199.94 (Russia)
80.66.75.11 (Russia)
193.143.1.5 (Russia)
176.111.174.92 (Russia)
176.113.115.135 (Russia)
176.113.115.136 (Russia)
176.113.115.84 (Russia)
176.111.174.109 (Russia)
vanaheim.cn (China)
I've also uploaded the extracted second stage as it's hash was undetected before. We can confirm the above IOCs under Behavior → 372a56f79f6c92c4dd78fafec96c28b0dc35fc79047e24f5a08997872d47aab4

![image](https://github.com/user-attachments/assets/b88b5689-6625-4e14-90b9-7a4736679706)

All of the above IOCs have been uploaded to Anomali and blocked → Import | ThreatStream

Zscaler activity was checked to see if there are connections to above IPs. None were found in the past 30 days.


Behavioral indicators:

- creating an 8-character randomized directory under C:\Windows\SysWOW64.
- dropping itself as an 8-character randomized executable file to**\AppData\Local\Temp** of the current user.
- persistence mechanism in form of a service that starts during user logon and uses svchost.exe from SysWOW64.
- service display name: "wifi support"
- service description: "wifi internet connection"
- firewall rule creation under name: "Host-process for services of Windows"
- Based on above behavioral indicators, a detection rule will be created in Chronicle.

**Summary**
Above analyzed Tofsee sample resembles activity of a backdoor/botnet. Initial stage has a small portion of its code encrypted, therefore entropy is not that high. After successful extraction tt then drops a second stage that installs itself as a service under SysWOW64 directory and denies access to the user due to local policies manipulation. It then creates a WSASocket connection to the remote IPs, presumably C2 infrastructure for further instructions.
